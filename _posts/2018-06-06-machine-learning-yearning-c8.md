---
layout:     post
title:      《机器学习要领》 调试推理算法（中文翻译版）
subtitle:   Machine Learning Yearning Chapter8 Debugging inference algorithms(Chinese ver)
date:       2018-06-21
author:     Canary
header-img: img/ML_yearning1.jpg
catalog: true
tags:
    - maching learning yearning
    - 机器学习
    - Andrew NG
    - 翻译
---

## 前言

> 本篇博客是 Andrew NG 《Machine Learning Yearning》 的“第八章：调试推理算法”翻译。本章内容将探讨用于调试语音识别系统、机器翻译系统和增强学习系统的共享 AI 设计模式是什么?。开启本章内容，出发！   
👉[官网传送门](http://www.mlyearning.org/)<br>
👉[GitHub项目传送门](https://github.com/AlbertHG/Machine-Learning-Yearning-Chinese-ver)，欢迎Star

## 44. 优化验证测试

假设你正在构建语言识别系统，你的系统通过输入音频片段 A 并为每一个输出的语句 S 计算可能性 $Score_A(S)$。例如，假设输入音频是 A，你可能会通过 
$Score_A(S) = P(S|A)$ 
来估计得分——即将音频 A 正确转录为句子 S 的概率。给定计算  $Score_A(S)$ 的方法，你需要找到使 $Score_A(S)$ 最大化的那个句子 S：

$$Output=arg\ \underset{S}{max}\ Score_A(S)$$

那么，该如何计算上式中的 “arg max”呢？如果我们的英文单词有 5 万个，那么一个长度为 $N$ 的句子中单词的组合的可能性则有 $(50000)^N$ 种，实在是太多了。所以，你可以应用一个近似的搜索算法来找到一个合理的 S 来优化（最大化）$Score_A(S)$。关于这种搜索算法，其中有一种叫做“集束搜索”(Beam Serach)，它在搜索过程中只保留前 K 个表现最好的作为候选值。（就本章而言，你无需了解关于“集束搜索”的细节）然而，这样的算法并不能保证找到一个 S 来最大化 $Score_A(S)$。

假设一个音频剪辑 A 记录了某人说“我喜欢机器学习”。但你的系统输出的不是正确的转录语句——音频被转录为了“我爱机器人”。出现这种错误有下列两种可能性：

1.  搜索算法的问题： 近似搜索算法（波束搜索）并没有找到能够最大化 $Score_A(S)$ 的 S 的值。
2. 目标（评分函数）问题：我们对$Score_A(S) = P(S\|A)$ 的估计是不准确的。特别是，我们选择的 $Score_A(S)$ 并不能体现出“我喜欢机器学习”才是正确的转录语句。

取决于不同失败的原因，你应该用不同的方式来优先考虑你的工作重心。如果是问题 #1，那么你应该努力去改进你的搜索算法；如果是问题 #2，你应该是着重去研究能够准确估算 $Score_A(S)$ 的学习算法。

面对这种情况，一些研究者会随机地选择搜索算法；另一些人则会随机选择一种更好的方法来学习 $Score_A(S)$ 的值，但是，除非你知道这些错误的根本原因，否则大部分努力都是白费的。那么，如何更系统地决定要做什么呢?

我们用 $S_{out}$ 来指代系统转录的输出——“我爱机器人”。用 $S^{* }$ 来指代正确的转录内容——“我爱机器学习”。为了深刻了解我们的系统出现的问题到底是上述的 #1 还是 #2 ，你可以执行优化验证测试(Optimization Verification test)：首先计算 $Score_A(S^{* })$ 和 $Score_A(S_{out})$，然后检查是否有 $Score_A(S^{* }) > Score_A(S_{out})$。在这里存在两种情况：

情况 1： $Score_A(S^{* }) > Score_A(S_{out})$

在这种情况下，您的学习算法已经正确给出 $S^{* }$ 比 $S_{out}$ 更高的分数。 尽管如此，我们的近似搜索算法依然选择了 $S_{out}$ 而不是 $S^{* }$。 这就说明了你的近似搜索算法没有选择最大化 $Score_A(S)$ 的 S 的值。换句话说，优化验证测试告诉了你：你有一个搜索算法问题，应该专注于此。 例如，您可以尝试增加集束搜索的集束宽度。

情况 2： $Score_A(S^{* }) \leq  Score_A(S_{out})$

在这种情况下，你知道计算 $Score_A(.)$ 的方式存在问题，它无法对正确的输出 $S^{* }$ 给出严格高于 $S_{out}$ 的分数。优化验证测试告诉您有一个目标(评分)函数问题，因此，你应该把注意力集中在如何为不同的句子 S 学习或者近似 $Score_A(S)$ 。

我们上述的讨论都集中在一个例子上。然而要在实践中应用优化验证测试，您应该检查开发集中的错误。 对于开发集中的每个错误，你都要检查评分是否满足 $Score_A(S^{* }) > Score_A(S_{out})$。 满足这个不等式的所有的开发集错误样本的错误原因都将被归咎为优化算法的问题，而不满足不等式的所有的开发集错误样本的错误原因则都将被归咎为计算 $Score_A(.)$ 的方式存在问题。

例如，假设您发现在所有的开发集错误样本中有 95% 的错误是由于评分函数 $Score_A(.)$导致的，而只有 5% 是由于优化算法所导致的。通过这个你就能得知，无论您如何改进优化过程，实际上您只会消除大约 5% 的错误。因此，你应该将重点放在如何准确评估 $Score_A(.)$ 的问题上。

## 45. 优化验证测试的一般形式

当给定一些输入 $x$ 时，您可以应用优化验证测试，您知道如何计算$Score_x(y)$，通过这个指标来衡量输出 $y$ 对输入 $x$ 的响应有多好。此外，你还正在使用一种近似算法试图找到 $arg\ max_y\ Score_x(y)$，但怀疑近似搜索算法有时并不能找到满足条件的最大值。在我们之前的例子中， $x=A$指代音频剪辑数据，$y=S$ 指代输出转录。

我们还是约定 $y^{* }$ 是“正确的”输出，算法的输出约定为 $y_{out}$。然后，关键的测试是衡量指标之间的关系是否满足 $Score_x(y^{* }) > Score_x(y_{out})$，如果这个不等式成立，那么我们将错误归咎于优化算法——请参考前一章，以确保您理解背后的逻辑——否则，我们则将错误归咎于 $Score_x(y)$ 的计算。

让我们再看一个例子。假设您正在构建一个汉英机器翻译系统。你的系统通过输入中文句子 C 并计算出每个可能的英文句子 E 的评分 $Score_C(E)$ 来选出最恰当的翻译句子。例如，你利用公式 
$Score_C(E) = P(E|C)$ 
来计算出在给定中文句子 C 的前提下，翻译出句子 E 的概率来。

您的算法通过尝试计算下列公式来翻译句子:

$$Output=arg\ \underset{E}{max}\ Score_C(E)$$

但是，所有可能的英语句子 E 的集合太大了，所以你需要依赖启发式搜索算法。

假设你的算法输出一个不正确的翻译 $E_{out}$ 而不是一些正确的翻译 $E^{* }$。然后，优化验证测试会要求你计算 $Score_C(E^{* }) > Score_C(E_{out})$，如果这个不等式成立，也就是说 $Score_C(.)$ 正确地判断出 $E^{* }$ 是 $E_{out}$ 的最优输出，则我们将错误归咎于算法优化不够好。否则，我们则将错误归咎于 $Score_x(y)$ 的计算。

在 AI 中，最常见的“设计模式”是先学习一个近似评分函数 $Score_C(.)$，然后使用近似最大化算法。如果你能够发现这种模式，你将能够使用优化验证测试来了解错误的来源。

## 46. 强化学习的例子

![](https://raw.githubusercontent.com/AlbertHG/alberthg.github.io/master/makedown_img/20180422mlyearning/19.png)

假设你正在使用机器学习来教直升机进行复杂的飞行操作。这是一个电脑控制器直升机在引擎关闭时执行着陆的延时照片。

这是一个被称为“自动旋转(autorotation)”策略。即使直升机的引擎意外失灵，它也能允许直升机降落。人类飞行员将练习这个策略作为他们训练的一部分。你的目标是使用一种学习算法让直升机通过一个轨迹 T 来安全着陆。

为了应用强化学习，你必须设置一个“奖励函数” $R(.)$ 它给出一个分数来衡量每个可能的轨迹 T 有多好。 例如，如果轨迹 T 导致直升机坠毁，那么回报可能是 $R(T) = -1000$ ——这可真是一个巨大的负面报酬啊。一个能够让飞机安全着陆的轨迹 T 可能会产生一个正值 $R(T)$，具体值则取决于着陆的顺利程度。 通常通过手动选择奖励函数 $R(.)$ 来量化不同轨迹 T 的理想程度。它必须权衡着陆的颠簸如何，直升机是否落在正确的位置，乘客下落的程度等等多方面因素。 设计出一个好的奖励函数并不是一件容易的事。

给定奖励函数 $R(T)$，增强学习算法的任务是控制直升机，使其达到 $max_TR(T)$。然而，强化学习算法在实现这一最大化的过程中，可能会产生很多近似值，这样就无法逼近这个最大值了。

假设你选择了一些奖励函数 $R(.)$ 并运行了你的学习算法。然而，算法的表现似乎比人类飞行员糟糕得多——着陆时的颠簸更大，看起来也比人类飞行员控制的飞机更加危险。那么，你应该如何来判断故障到底是因为强化学习算法在试图找到一条轨迹 T 来实现 $max_TR(T)$ 呢？还是由于奖励函数试图在飞机降落颠簸度和飞机降落准确度之间的权衡导致的？

为了应用优化验证试验，设 $T_{human}$ 为人类飞行员所控制飞机的轨迹，设 $T_{out}$ 为算法控制飞机所实现的轨迹。根据我们上面的描述，$T_{human}$ 是 $T_{out}$ 的最优轨迹。因此关键的测试被等价为不等式是否满足：$R(T_{human}) >R(T_{out})$？

情形1：如果这个不等式成立，那就意味着，从奖励函数 $R(.)$ 中确实能得出 $R(T_{human})$ 优于 $R(T_{out})$ 的结论。也就是说我们的强化学习算法找到的是一个不是很优秀的 $T_{out}$，这表明，我们的强化学习算法还需改进。

情形2：假设不等式是 $R(T_{human}) \leq R(T_{out})$，这意味着即使我们知道 $T_{human}$ 是非常优秀路线，但是奖励函数 $R(.)$ 却给它分配了一个很差劲的分数。这表明，你应该努力改进 $R(.)$ 以更好地去捕捉与良好着陆相符的权衡。

许多机器学习应用程序都有使用近似搜索算法优化近似评分函数 $Score_X(.)$ 的“模式”。有时，没有指定的输入 $x$，则可以将评分函数简化为 $Score_(.)$。在我们上面的例子中，评分函数是奖励函数 $Score(T)= R(T)$，优化算法则具体为是一个试图让直升机执行良好轨迹 T 的强化学习算法。

与前面的示例不同的是，我们一直都是在与人类级别的性能 $T_{human}$ 进行比较，而不是“最佳”输出。我们假设人类级别的性能 $T_{human}$ 很好，即使不是“最佳”。一般来说，只要你有 $y^{* }$ （在本例中是 $T_{human}$ ）即使它不是“最优”输出，它也是你当前学习算法性能的优秀输出，那么优化验证测试依然能指导你确定优化算法和评分函数的改进方向。


------

🚧🚧未完待续🚧🚧