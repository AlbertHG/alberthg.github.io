---
layout:     post
title:      结构化机器学习项目
subtitle:    "\"deeplearning.ai-Class3-Week1\""
date:       2018-04-12
author:     ATuk
header-img: img/deeplearning_c3_w1.jpg
catalog: true
tags:
    - deep learning
    - 笔记
    - deeplearning.ai
    - 网易云课堂
    - 编程作业
---

## [GitHub项目传送门](https://github.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai)

> 欢迎Star

## 机器学习策略(1)

### 为什么是ML策略

对于一个已经被构建好且产生初步结果的机器学习系统，为了能使结果更令人满意，往往还要进行大量的改进。鉴于之前的课程介绍了多种改进的方法，例如收集更多数据、调试超参数、调整神经网络的大小或结构、采用不同的优化算法、进行正则化等等，有针对性的调整才能事半功倍。

### 正交化

搭建机器学习系统的挑战之一便是可以尝试和改变的东西太多了。**正交化（Orthogonalization）** 的核心在于每次调整只会影响模型某一方面的性能，而对其他功能没有影响。这种方法有助于更快更有效地进行机器学习模型的调试和优化。

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/01.png)

上图左侧是一张老式电视图片，有很多旋钮可以用来调整图像的各种性质。这些老式电视可能有一个旋钮来调整图像垂直方向的高度、一个旋钮用来调节图像的宽度、一个旋钮用来调节梯形角度、一个旋钮用来调节图像的左右偏移，还有一个旋钮用来调节图像选择的角度等。电视设计师花了大量时间设计电路来确保每个旋钮都有相对明确的功能，正交化指的就是电视设计师在设计旋钮时，让每个旋钮都只调整电视的一个方面。

要设计好一个有监督学习系统，需要设计好调整系统的“旋钮”来确保下图所提及的四件事情，也就是说要确保一下四点互为正交（修改其中一条不会影响其他）:

1. 当设计的算法 **在成本函数上不能很好地拟合训练集时(训练集表现不好)** ，就应该设计一个“旋钮”确保可以调整算法使得它很好地拟合训练集。例如训练更大的网络或者切换到像 Adam 算法之类的更好的优化算法等。
2. 当设计的算法 **对训练集的拟合很好但对开发集的拟合很差时（验证(开发)集上表现不好）** ，可以使用正则化或者更好的训练集等“旋钮”来调整。
3. 当设计的算法 **对开发集的拟合很好但对测试集的拟合很差时（测试集上表现不好）** ，意味着过拟合了，可以使用更大的开发集这个“旋钮”来调整。
4. 当设计的算法 **对测试集的拟合很好但在实际情况中却无法表现得很好时（实际应用中表现不好）** ，此时可以选择改变开发集或成本函数。

### 单一数字评估指标

构建机器学习系统时，通过设置一个量化的单值评价指标（single-number evaluation metric），可以使我们根据这一指标比较不同超参数对应的模型的优劣，从而选择最优的那个模型。

评估你的分类器的一个合理方式是观察它的查准率（Precision）和查全率（Recall）,对于猫分类器这个案例:

- 查准率的定义是在分类器标记为猫的例子中，有多少真的是猫。 $$\frac{预测为正类的正类数量}{预测为正类的数量} * 100% $$
- 查全率就是分类器正确识别出的真是猫的图片数量占所有的真是猫的图片数量的百分比。 $$\frac{预测为正类的正类数量}{正类数量} * 100% $$

假设我们有 A 和 B 两个分类器，其两项指标分别如下：

| 分类器 | 查准率 | 查全率 |
| :---: | :---: | :---: |
| A | 95% | 90% |
| B | 98% | 85% |

A 的查全率较高，B 的查准率较高，一时无法二选一，所以难以使用两个评估指标——查准率和查全率，来快速地选择一个分类器，这就需要找到一个新的评估指标能够结合查准率和查全率。在机器学习中，结合查准率和查全率的标准方法是所谓的 **F1 分数** ，可以认为这是查准率 P 和查全率 R 的平均值。正式来说，F1 score 的公式叫做查准率 P 和查全率 R 的调和平均数。
$$F1 = \frac{2}{\frac{1}{P}+\frac{1}{R}} = \frac{2PR}{P+R}$$

因此，我们计算出两个分类器的 F1 Score。可以看出 A 模型的效果要更好。

| 分类器 | 精确率 | 召回率 | F1 Score |
| :---: | :---: | :---: | :---: |
| A | 95% | 90% | 92.4% |
| B | 98% | 85% | 91.0% |

通过引入单值评价指标，就可以加速改进机器学习算法的迭代过程。

### 满足和优化指标

有时候，要把所有的性能指标都综合在一起，构成单值评价指标是比较困难的。解决办法是，我们可以把某些性能作为优化指标（Optimizing metic），寻求最优化值；而某些性能作为满意指标（Satisficing metic），只要满足阈值就行了。

举个猫类识别的例子，有A，B，C三个模型，各个模型的Accuracy和Running time如下表中所示：

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/02.jpg)

Accuracy和Running time这两个性能不太合适综合成单值评价指标。因此，我们可以将Accuracy作为优化指标（Optimizing metic），将Running time作为满意指标（Satisficing metic）。也就是说，给Running time设定一个阈值，在其满足阈值的情况下，选择Accuracy最大的模型。如果设定Running time必须在100ms以内，那么很明显，模型C不满足阈值条件，首先剔除；模型B相比较模型A而言，Accuracy更高，性能更好。

概括来说，性能指标（Optimizing metic）是需要优化的，越优越好；而满意指标（Satisficing metic）只要满足设定的阈值就好了。

### 训练集、开发集、测试集的划分

训练集(Train sets)、开发(验证)集(Dev sets)、训练集(Test sets)如何设置对机器学习的模型训练非常重要，合理设置能够大大提高模型训练效率和模型质量。

机器学习的流程就是尝试很多思路，用训练集训练不同的模型，然后使用开发集来评估不同的思路，最终选择其中一个思路。之后不断地迭代去改善性能，直到得到一个令人满意的结果。最后，再用测试集去评估它。

原则上应该尽量保证Dev sets和Test sets来源于同一分布且都反映了实际样本的情况。如果Dev sets和Test sets不来自同一分布，那么我们从Dev sets上选择的“最佳”模型往往不能够在Test sets上表现得很好。这就好比我们在Dev sets上找到最接近一个靶的靶心的箭，但是我们Test sets提供的靶心却远远偏离Dev sets上的靶心，结果这支肯定无法射中Test sets上的靶心位置。

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/03.jpg)

### 开发集和测试集的大小

过去数据量较小（小于 1 万）时，通常将数据集按照以下比例进行划分：

* 无验证集的情况：70% / 30%；
* 有验证集的情况：60% / 20% / 20%；

这是为了保证验证集和测试集有足够的数据。现在的机器学习时代数据集规模普遍较大，例如 100 万数据量，这时将相应比例设为：

-  有验证集的情况：98% / 1% / 1%
-  无验证集的情况：99% / 1%

就已经能保证验证集和测试集的规模足够。

对于Dev sets数量的设置，应该遵循的准则是通过Dev sets能够检测不同算法或模型的区别，以便选择出更好的模型。

对于Test sets数量的设置，应该遵循的准则是通过Test sets能够反映出模型在实际中的表现。

实际应用中，可能只有Train/Dev sets，而没有Test sets。这种情况也是允许的，只要算法模型没有对Dev sets过拟合。但是，条件允许的话，最好是有Test sets，实现无偏估计。

### 什么时候改变开发/测试集和评估指标

算法模型的评价标准有时候需要根据实际情况进行动态调整，目的是让算法模型在实际应用中有更好的效果。

举个猫类识别的例子。初始的评价标准是错误率，算法A错误率为3%，算法B错误率为5%。显然，A更好一些。但是，实际使用时发现算法A会通过一些色情图片，但是B没有出现这种情况。从用户的角度来说，他们可能更倾向选择B模型，虽然B的错误率高一些。这时候，我们就需要改变之前单纯只是使用错误率作为评价标准，而考虑新的情况进行改变。例如增加色情图片的权重，增加其代价。

原来的Cost function：

$$J = \frac{1}{m}\sum_{m}^{i=1}L(\hat{y}^{(i)},y^{(i)})$$

更改评价标准后的Cost function：

$$J = \frac{1}{w^{(i)}}\sum_{m}^{i=1}w^{(i)}L(\hat{y}^{(i)},y^{(i)}),where\begin{cases} 1&\text{ if } x^{(i)} =non-porn \\ 10&\text{ if } x^{(i)} =porn \end{cases}$$

这样通过设置权重，当算法将色情图片分类为猫时，误差项会快速变大。

应该将机器学习任务看成两个独立的步骤:

1. 用打靶来打个比方，第一步就是设定目标，这是独立的一步。(定义一个指标来评估分类器)
2. 第二步则是瞄准和射击目标，即如何精确瞄准和如何命中目标。

### 为什么是人的表现

机器学习模型的表现通常会跟人类水平表现作比较，如下图所示：

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/4.jpg)

上图展示了随着时间的推进，机器学习系统和人的表现水平的变化。一般的，当机器学习超过人的表现水平后，它的进步速度逐渐变得缓慢，最终性能无法超过某个理论上限，这个上限被称为 **贝叶斯最优误差（Bayes Optimal Error）** 。

贝叶斯最优误差一般认为是理论上可能达到的最优误差，换句话说，其就是理论最优函数，任何从 x 到精确度 y 映射的函数都不可能超过这个值。例如，对于语音识别，某些音频片段嘈杂到基本不可能知道说的是什么，所以完美的识别率不可能达到 100%。

因为人类对于一些自然感知问题的表现水平十分接近贝叶斯最优误差，所以当机器学习系统的表现超过人类后，就没有太多继续改善的空间了。

也因此，只要建立的机器学习模型的表现还没达到人类的表现水平时，就可以通过各种手段来提升它。例如采用人工标记过的数据进行训练，通过人工误差分析了解为什么人能够正确识别，或者是进行偏差、方差分析。

当模型的表现超过人类后，这些手段起的作用就微乎其微了。

### 可避免偏差

模型在训练集上的误差与人类表现水平的差值被称作可避免偏差（Avoidable Bias）

假设针对两个问题分别具有相同的训练误差和交叉验证误差，如下所示：

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/5.jpg)

对于左边的问题，人类的误差为 1% ，对于右边的问题，人类的误差为 7.5% 。

对于某些任务如计算机视觉上，人类能够做到的水平和贝叶斯误差相差不远。（这里贝叶斯误差指最好的分类器的分类误差，也就是说没有分类器可以做到 100% 正确）。这里将人类水平误差近似为贝叶斯误差。

- 左边的例子： 8% 与 1% 差距较大

主要着手减少偏差，即减少训练集误差和人类水平误差之间的差距，来提高模型性能,比如训练更大的神经网络或者运行梯度下降更久一点。

- 右边的例子： 8% 与 7.5% 接近

主要着手减少方差，即减少开发集误差和测试集误差之间的差距，来提高模型性能,比如正则化或者收集更多的训练数据使得开发误差更接近训练误差。

也就是说：通常，我们把训练集误差与人类水平误差之间的差值称为偏差（bias），也称作可避免偏差（avoidable bias）；把开发集误差与训练集误差之间的差值称为方差（variance）。

### 理解人类的表现

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/06.png)

比如在上图的例子中:

- 第一个例子的训练误差是 5%，开发误差是 6%，而人类水平误差根据需要可以定义为 1%、0.7%或 0.5%。不论如何定义人类水平误差，在第一个例子中，它的可避免偏差大概是 4%，衡量方差的指标是 1%。此时，明显可避免偏差问题更大，在这种情况下，应该专注于减少偏差的技术，例如训练更大的网络。

- 在第二个例子中，训练误差是1%，开发误差是 5%，所以可避免偏差大概是 0%到 0.5%，衡量方差的指标是 4%，此时方差问题更大，应该主要使用减少方差的工具，比如正则化或者去获取更大的训练集。

- 在第三个例子中，训练误差是 0.7%，开发误差是 0.8%，此时选择哪个人类水平误差来估计贝叶斯最优误差就会对之后所采取的策略产生较大的影响。例如将人类水平误差定义为 0.5%，那么可避免偏差就是衡量方差的指标的两倍，这表明也许偏差和方差都存在问题，但可避免偏差问题更严重。但如果使用 0.7%来代替贝叶斯最优误差，那么会得到可避免偏差是 0%，这就可能导致忽略可避免偏差，而实际上应该继续尝试能不能在训练集上做得更好。

由上述例子就可以理解为什么在机器学习问题上取得进展会变得越来越难。因为当接近人类水平之后，想取得进展就变得很困难。例如在上面例子中，一旦接近了人类水平，那么就很难去判断是否应该继续去拟合训练集。 当然，这种问题只会出现在算法已经做得很好的情况下。例如在上图左侧的两个例子中，它们远离人类水平，此时选择将优化目标放在偏差还是方差上就可能更容易一些。这也说明了为什么接近人类水平之后，很难去分辨出问题是出在偏差上还是方差上。

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/07.png)

### 超越人类的表现

现在如果一个人类专家团和单个人类专家的表现和以前一样，但是算法可以得到 0.3%的训练误差还有 0.4%的开发误差。这是否意味着过拟合了 0.2%，又或者贝叶斯误差其实是更小的值？

在这种情况下，其可避免偏差就很难知晓是多少，同时也就没有足够的信息来判断优化算法应该专注减少偏差还是减少方差。这就会使得算法取得进展的效率降低。另外比如说算法的误差已经比人类专家的误差更低，那么依靠人类的直觉来判断算法还能往什么方向优化就很困难。所以，在这个例子中，一旦算法的误差小于 0.5%，那么就没有明确的选项和前进的方向了。但这并不意味着就不能取得进展，只是一些帮助指明方向的工具就没那么好用。

### 改善你的模型表现

想让一个监督学习算法达到使用程度，应该做到以下两点：

1. 算法对训练集的拟合很好，可以看作可避免偏差很低；
2. 如果算法在训练集上表现得很好，那么就将其推广到开发集和测试集，使得算法在这两个数据集上也表现得很好，也就是说方差不是太大。

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/08.png)

总结一下本章到目前为止的内容：如果想要提升机器学习系统的性能：

1. 那么首先计算训练误差与贝叶斯最优误差估计值之间的差值，得到可避免偏差的大小。
2. 然后计算开发集误差与训练误差之间的差值，这可以衡量方差问题的严重性。
    - 通过它们直接的对比，如果发现更需要尽可能地减少可避免偏差，那么可以使用例如构建规模更大的模型、训练的时间更长、使用更好的优化算法（比如 momentum、RMSprop 或者 Adam）、寻找更好的新神经网络架构或更好的超参数等策略。
    - 另外，如果当发现方差问题严重时，可以使用例如收集更多的数据、正则化（包括 L2 正则化、Dropout 或数据增强）、试用不同的神经网络架构、超参数搜索等技巧。

## 机器学习策略(2)

### 误差分析

如果试图让学习算法完成通常由人类所做的任务，但它并没达到人类水平的话，就需要人工检查一下学习算法所犯的错误，这有助于了解接下来需要去做什么，这个过程被称为 **误差分析** 。

例如，你可能会发现一个猫图片识别器错误地将一些看上去像猫的狗误识别为猫。这时，立即盲目地去研究一个能够精确识别出狗的算法不一定是最好的选择，因为我们不知道这样做会对提高分类器的准确率有多大的帮助。所以一个好的误差分析的流程就相当重要。

收集错误样例：

我们可以从分类错误的样本中统计出狗的样本数量。根据狗样本所占的比重来判断这一问题的重要性。

- 假如狗类样本所占比重仅为 5%，那么即使花费几个月的时间来提升模型对狗的识别率，改进后的模型错误率并没有显著改善；
- 而如果错误样本中狗类所占比重为 50%，那么改进后的模型性能会有较大的提升。因此，花费更多的时间去研究能够精确识别出狗的算法是值得的。

并行分析（举例）：

- 修改那些被分类成猫的狗狗图片标签；
- 修改那些被错误分类的大型猫科动物，如：狮子，豹子等；
- 提升模糊图片的质量。

为了并行的分析，建立表格来进行。以单个错误分类样本为对象，分析每个样本错误分类的原因。

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/09.jpg)

在表格的最左侧，列出需要分析的图像集，然后使用另外几列对应评估的想法。最后一列则通常被留下用来写评论（或者备注）。当填满整个表格后，就可以统计这些算法（错误）的百分比或者每个错误类型的百分比。例如下图所示的情况，检查的图像中 8%是狗、43%是其他的猫科动物，另外 61%是模糊的图像。

在分析过程中，有时会发现其他错误类型，比如可能发现有 Instagram 滤镜干扰了分类器。出现这种情况时，只需要在分析时在电子表格中增加这样的一列，也将其纳入误差分析中即可。

最后，统计错误类型的百分比，这个分析步骤可以给我们一个粗略的估计，让我们大致确定是否值得去处理每个不同的错误类型。

总结一下，进行误差分析首先应该找一组错误例子，这些错误例子可能在开发集或者测试集里。然后观察这些错误标记的例子，统计属于不同错误类型的错误数量。在这个过程中，有时可能会得到启发，归纳出新的误差类型，例如本小节例子所提的 lnstagram 的滤镜问题。那么，针对这一新类型可以在表格中新建一个错误类型，将其纳入误差分析中。总之，通过统计不同错误标记类型占总数的百分比将有助于发现哪些问题需要优先解决，或者能够提供构思新优化方向的灵感。

### 清除标注错误的数据

我们用 mislabeled examples 来表示学习算法输出了错误的 Y 值。而在做误差分析时，有时会注意到数据集中有些样本被人为地错误标记（incorrectly labeled）了，这时该怎么做？

如果是在训练集中，由于机器学习算法对于随机误差的 **稳健性（Robust）** （也称作“鲁棒性”），只要这些出错的样本数量较小，且分布近似随机，就不必花费时间一一修正。

而如果出现在验证集或者测试集，则可以在进行误差分析时，通过统计人为标记错误所占的百分比，来大致分析这种情况对模型的识别准确率的影响，并比较该比例的大小和其他错误类型的比例，以此判断是否值得去将错误的标记一一进行修正，还是可以忽略。

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/10.jpg)

上图例子中，假设它所占的百分比是 6%，那么是否值得修正这 6%的标记出错的例子呢？

这里有三个指标来确定是否值得去人工修正标记出错的数据。

1. 应该关注整体的开发集误差，假设在本例中是 10%。
2. 然后，应该查看错误标记引起的错误的数量或者百分比，在这个例子中，6%的错误来自标记出错，也就是 0.6%。
3. 最后，应该查看其他原因导致的错误。
    - 在本例中，假设开发集上有 10%的错误，其中 0.6%是因为标记出错，其他原因所导致的错误占 9.4%。在这种情况下，其他原因所导致的 9.4%的误差需要集中精力修正，而标记出错导致的错误是总体错误的一小部分而已。
    - 如果误差降到了 2%，但是总体错误中的 0.6%还是标记出错导致的，那么此时去检查一组标记出错的开发集图片就是相对合理的。

我们知道，开发集的主要作用是在不同算法之间进行比较，选择错误率最小的算法模型。但是，如果有标记出错的数据（0.6%）的存在，当不同算法（两个分类器A 和 B 时，在开发集上一个有 2.1%的误差，另一个有 1.9%的误差）错误率比较接近的时候，我们无法仅仅根据开发集上测试的结果准确指出哪个算法模型更好，必须修正标记出错的数据。

当你决定在验证集和测试集上手动检查标签并进行修正时，有一些额外的方针和原则需要考虑：

* 在验证集和测试集上 **同时使用同样的修正手段** ，以保证验证集和测试集来自相同的分布；
* 同时检查判断正确和判断错误的例子（通常不用这么做）；
* 在修正验证集和测试集时，鉴于训练集的分布不必和验证/测试集完全相同，可以不去修正训练集（学习算法是相当鲁棒的）。

### 快速搭建第一个系统并开始迭代

对于如何构建一个机器学习应用模型，Andrew给出的建议是先快速构建第一个简单模型，然后再反复迭代优化。

- 设置训练、开发、测试集和优化指标（确定方向）；
- 快速训练出一个初步的系统，用训练集来拟合参数，用验证集调参，用测试集评估；
- 使用偏差方差分析、误差分析去确定后面步骤的优先步骤。

### 在不同分布上的训练集和测试集

在深度学习的时代，因为需求的数据量非常大，现在很多的团队，使用的训练数据都是和开发集和测试集来自不同的分布。

下面是一些处理训练集和测试集存在差异的最佳的做法。以前一周中的猫的分类问题为例：假设现在想识别一个手机应用中用户上传的他们用手机拍摄的照片是不是猫？

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/11.png)

现在存在的现状是：我们可以从网上获取大量的高清晰的猫的图片200000张， 从手机获取拍摄的不清晰的图片10000张。但是我们系统的目的是应用到手机上做分类。也就是说，我们的训练集和开发集、测试集来自于不同的分布。

比较好的方法是：将从网页下载的200000张图片都设为训练集，如果需要的话，再加上5000张来自手机上传的图片。至于开发集和测试集则都是来自手机上传的图片，例如将 2500 张来自手机上传的图片作为开发集，剩下的 2500 张作为测试集。

- 好处：开发集全部来自手机图片，瞄准目标；
- 坏处：训练集和开发、测试集来自不同的分布。

从长期来看，这样的分布能够给我们带来更好的系统性能。

### 数据分布不匹配的偏差和方差分析

之前的学习中，我们通过比较人类水平误差、训练集错误率、验证集错误率的相对差值来判断进行偏差（人类水平误差和训练集错误率差值）/方差（人类水平误差和验证集错误率差值）分析。

- 假设例子中训练误差是 1%，开发误差是 10%。如果开发集来自和训练集一样的分布，那么比对之下就可以发现这里存在很大的方差问题。

但在训练集和验证/测试集分布不一致的情况下，无法根据相对差值来进行偏差/方差分析。这是因为训练集错误率和验证集错误率的差值可能来自于算法本身（归为方差），也可能来自于样本分布不同。

- 比如可能因为训练集都是高分辨率、很清晰的图片，所以很容易识别，但开发集上的图片可能由于图片分辨率不高等而难以识别。即可能算法本身没有方差问题，这只不过是反映了开发集包含更难以精确分类的图片。

那么我们如何去确定是由于分布不匹配的问题导致开发集的误差，还是由于算法中存在的方差问题所致？

为了解决这个问题，我们可以再定义一个训练-验证集（Training-dev Set）。训练-验证集和训练集的分布相同（或者是训练集分割出的子集），但是不参与训练过程。*可理解为模型本身的开发集由于和测试集不同分布，所以人为从测试集抽出一部分集合作为开发集* 。

- 计算训练集、训练-开发集和开发集上的误差。
    1. 假设模型得到的误差如下结果：
        - Training error： 1%
        - Training-dev error： 9%
        - Dev error： 10%
        - 贝叶斯最优误差大概是 0%

    *可以发现当算法运行在训练-开发集上时，误差上升了很多，这就说明了算法存在方差问题，因为训练-开发集是和训练集来自同一分布。*

    2. 但如果模型得到的误差分别为：
        - Training error： 1%
        - Training-dev error： 1.5%
        - Dev error： 10%
        - 贝叶斯最优误差大概是 0%

    *那么在这样的情况下，我们可以看到，来自同分布的数据，模型的泛化能力强，而开发集的误差主要是来自于分布不匹配导致的。*

    3. 但如果模型得到的误差分别为：
        - Training error： 10%
        - Training-dev error： 11%
        - Dev error： 12%
        - 贝叶斯最优误差大概是 0%

    *那么在这样的情况下，那么就真的存在偏差问题，因为算法做得比人类水平要差很多。*

    4. 但如果模型得到的误差分别为：
        - Training error： 10%
        - Training-dev error： 11%
        - Dev error： 20%
        - 贝叶斯最优误差大概是 0%

    *那么在这样的情况下，同时有两个问题：一是可避免偏差相当高，另一个是数据不匹配问题。*

有了“训练集错误率”、“训练-验证集错误率”，以及“验证集错误率”。

- “训练集错误率”和“人类水平误差（贝叶斯最优误差）”的差值反映了 **可避免偏差(Avoidable bias)** ；
- 其中，“训练集错误率”和“训练-验证集错误率”的差值反映了 **方差(variance)** ；
- 而“训练-验证集错误率”和“验证集错误率”的差值反映了 **样本分布不一致的问题** ，从而说明模型擅长处理的数据和我们关心的数据来自不同的分布，我们称之为 **数据不匹配（Data Mismatch）** 问题；
- “开发集错误率”和“测试集错误率”的差值反映了开发集的 **过拟合** 水平。

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/12.jpg)

一般情况下，人类水平误差、训练集错误率、训练-验证集错误率、验证集错误率以及测试集错误率的数值是递增的，但是也会出现验证集错误率和测试集错误率下降的情况。这主要可能是因为训练样本比验证/测试样本更加复杂，难以训练。

### 处理数据不匹配的问题

这里有两条关于如何解决数据不匹配问题的建议：

* 做错误分析，尝试了解训练集和验证/测试集的具体差异（主要是人工查看训练集和验证集的样本）；
* 尝试将训练数据调整得更像验证集，或者收集更多类似于验证/测试集的数据。

如果你打算将训练数据调整得更像验证集，可以使用的一种技术是人工合成数据。我们以语音识别问题为例，实际应用场合（验证/测试集）是包含背景噪声的，而作为训练样本的音频很可能是清晰而没有背景噪声的。为了让训练集与验证/测试集分布一致，我们可以给训练集人工添加背景噪声，合成类似实际场景的声音。

人工合成数据能够使数据集匹配，从而提升模型的效果。但需要注意的是，不能给每段语音都增加同一段背景噪声，因为这样模型会对这段背景噪音出现过拟合现象，使得效果不佳。

### 迁移学习

**迁移学习（Tranfer Learning）** 是通过将已训练好的神经网络模型的一部分网络结构应用到另一模型，将一个神经网络从某个任务中学到的知识和经验运用到另一个任务中，以显著提高学习任务的性能。

例如，我们将为猫识别器构建的神经网络迁移应用到放射科诊断中。因为猫识别器的神经网络已经学习到了有关图像的结构和性质等方面的知识，利用之前的神经网络模型，只改变神经网络中原有的输出层，加入新的输出层并随机初始化权重系数（$W^{[L]}$、$b^{[L]}$），而其它层所有的权重系数$W^{[l]}$、$b^{[l]}$）不变，随后用新的训练集进行训练，就完成了以上的迁移学习。

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/13.png)

如果新的数据集很小，可能只需要重新训练输出层前的最后一层的权重，即$W^{[L]}$、$b^{[L]}$，并保持其他参数不变；而如果有足够多的数据，可以只保留网络结构，重新训练神经网络中所有层的系数。这时初始权重由之前的模型训练得到，这个过程称为 **预训练（Pre-Training）** ，之后的权重更新过程称为 **微调（Fine-Tuning）** 。

你也可以不止加入一个新的输出层，而是多向神经网络加几个新层。

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/14.jpg)

迁移学习起作用的场合是迁移来源有很多某个问题的数据，但迁移目标问题却没有那么多数据。假如图像识别任务中有 1 百万个样本，这就有足够的数据帮助神经网络学习低层次特征。如果放射科任务只有一百个样本，那么就意味着放射科诊断问题的数据很少，这时，将从图像识别训练中学习到的很多知识迁移到放射科诊断问题就是合理的。

**迁移学习之所以能这么做的原因是，神经网络浅层部分能够检测出许多图片固有特征，例如图像边缘、曲线等。使用之前训练好的神经网络部分结果有助于我们更快更准确地提取X光片特征。二者处理的都是图片，而图片处理是有相同的地方，第一个训练好的神经网络已经帮我们实现如何提取图片有用特征了。 因此，即便是即将训练的第二个神经网络样本数目少，仍然可以根据第一个神经网络结构和权重系数得到健壮性好的模型。**

在下述场合进行迁移学习是有意义的：

1. 两个任务有同样的输入（比如都是图像或者都是音频）；
2. **拥有更多数据的任务迁移到数据较少的任务** ；
3. 某一任务的低层次特征（底层神经网络的某些功能）对另一个任务的学习有帮助。

### 多任务学习

迁移学习中的步骤是串行的；而 **多任务学习（Multi-Task Learning）** 使用单个神经网络模型来同时实现多个任务，学习是同时开始的，并且任务之间可以相互促进。

以汽车自动驾驶为例，需要实现的多任务是：不只是要判断图片是否为行人图片、车辆版、交通标志和信号灯图片，而是要知道每张照片是否有行人、汽车、停车标记或者交通灯。如果在输入的图像中检测出车辆和交通标志，则输出的 y 为：

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/15.png)

多任务学习模型的成本函数为：

$$\frac{1}{m} \sum^m_{i=1} \sum^c_{j=1} L(\hat y_j^{(i)}, y_j^{(i)})$$

其中，j 代表任务下标，总有 c 个任务。对应的损失函数为：

$$L(\hat y_j^{(i)}, y_j^{(i)}) = -y_j^{(i)} log \hat y_j^{(i)} - (1 -y_j^{(i)})log(1 - \hat y_j^{(i)})$$

多任务学习是使用单个神经网络模型来实现多个任务。实际上，也可以分别构建多个神经网络来实现。多任务学习中可能存在训练样本 Y 某些标签空白的情况，这不会影响多任务学习模型的训练。

多任务学习和 Softmax 回归看上去有些类似，容易混淆。它们的区别是，Softmax 回归的输出向量 y 中只有一个元素为 1；而多任务学习的输出向量 y 中可以有多个元素为 1。

在下述场合进行多任务学习是有意义的：

1. 训练的一组任务可以共用低层次特征；
2. *通常* ，每个任务的数据量接近(任务 A_1，...，A_n) ，每个任务均有1000个数据，合起来就有1000n个数据，共同帮助任务的训练,所以如果想要使用多任务学习来大幅地提升性能，那么其他任务加起来必须要有比单个任务大得多的数据量)；
3. 能够训练一个足够大的神经网络，以同时做好所有的工作。多任务学习会降低性能的唯一情况（即和为每个任务训练单个神经网络相比性能更低的情况）是神经网络还不够大。

在实践中，多任务学习的使用频率要远低于迁移学习。计算机视觉领域中的物体识别是一个多任务学习的例子。

### 何为端到端的深度学习

端到端（end-to-end）深度学习就是将所有不同阶段的数据处理系统或学习系统模块组合在一起，用一个单一的神经网络模型来实现所有的功能。它将所有模块混合在一起，只关心输入和输出。

语音识别例子：

![](https://raw.githubusercontent.com/AlbertHG/Coursera-Deep-Learning-deeplearning.ai/master/03-Structuring%20Machine%20Learning%20Projects/md_images/16.jpg)

### 优点与缺点

应用端到端学习的优点：

* 只要有足够多的数据，剩下的全部交给一个足够大的神经网络。比起传统的机器学习分块模型，可能更能捕获数据中的任何统计信息，而不需要用人类固有的认知（或者说，成见）来进行分析；
* 所需手工设计的组件更少，简化设计工作流程；

缺点：

* 需要大量的数据；
* 排除了可能有用的人工设计组件；

根据以上分析，决定一个问题是否应用端到端学习的**关键点**是：是否有足够的数据，支持能够直接学习从 x 映射到 y 并且足够复杂的函数？
